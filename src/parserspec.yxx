/* yacc grammar for C++ */
%require "3.2"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%defines
%output "parser.cpp"

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code{
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.lex
}

%define api.token.prefix {TOK_}
%token <std::string> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> NUMBER "number"                  // This defines TOK_NUMBER
%token <std::string> TRUE "true"
%token <std::string> FALSE "false"
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVETO "moveto"
%token <std::string> LAMBDA "lambda"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%token <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> LEFT_BRACE "{"
%token <std::string> RIGHT_BRACE "}"
%token <std::string> LEFT_PAREN "("
%token <std::string> RIGHT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> AND_OP "&&"
%token <std::string> OR_OP "||"
%token <std::string> LESS_EQUAL "=<"
%token <std::string> GREATER_EQUAL "=>"
%token <std::string> LESS "<"
%token <std::string> GREATER ">"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%%

program: /* empty */ | event_def_header | dec_stmt;
dec_stmt: dec_term | dec_stmt dec_term;
dec_term: types IDENTIFIER ASSIGN exprs SEMI;
exprs: cond_expr | add_expr;
add_expr: NUMBER | add_expr op NUMBER;
cond_expr: cond_term | cond_expr logic_op cond_term;
cond_term: logic_vals | logic_terms cond logic_terms | 
           LEFT_PAREN logic_terms cond logic_terms RIGHT_PAREN;
logic_terms: NUMBER | logic_vals;
logic_vals: TRUE | FALSE;
logic_op: AND_OP | OR_OP;
cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;
event_def_header: event_def_term | event_def_header event_def_term;
event_def_term: DEFEVENT IDENTIFIER LEFT_PAREN args_term RIGHT_PAREN SEMI;
args_term: types | args_term COMMA types;
op: PLUS;
types: INT | BOOL | STRING;



/*
types: INT | BOOL | STRING;

op: PLUS;

cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;

dec_stmt: types IDENTIFIER ASSIGN expr SEMI | lambda_meth;
*/

/*
if_term: IF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
elif_term: ELIF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
else_term: ELSE LEFT_BRACE ... RIGHT_BRACE
elif_block: elif_term | elif_block elif_term;
if_stmt: if_term | if_term elif_block | if_term elif_block else_term

logic_term: NUMBER | TRUE | FALSE
logic_op: AND_OP | OR_OP
cond_expr: cond_term | cond_expr logic_op cond_term
cond_term: logic_term | logic_term cond logic_term

args_term: types | args_term COMMA types
args_iden_term: types IDENTIFIER | args_iden_term COMMA types IDENTIFIER

event_def_header: DEFEVENT IDENTIFIER LEFT_PAREN args_term RIGHT_PAREN SEMI

if_event_stmt: IF LEFT_PAREN cond_expr RIGHT_PAREN MOVETO IDENTIFIER LEFT_BRACE ...
on_event_stmt: ON IDENTIFIER LEFT_BRACE if_event RIGHT_BRACE
while_stmt: WHILE LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
return_term: RETURN ...
method_term: types IDENTIFIER LEFT_PAREN args_iden_term RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
entry_meth: ENTRY LEFT_BRACE ... RIGHT_BRACE
exit_meth: EXIT LEFT_BRACE ... RIGHT_BRACE
lambda_meth: LAMBDA LEFT_PAREN args_iden_term RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
add_expr: NUMBER | add_expr op NUMBER
state_term: STATE IDENTIFIER LEFT_BRACE entry_meth exit_meth ... RIGHT_BRACE

stmts_list: dec_stmt | if_stmt | on_event_stmt | while_stmt
*/

%%

void yy::parser::error(const std::string& msg)
{
    std::cerr << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}