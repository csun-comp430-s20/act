/* yacc grammar for C++ */
%require "3.2"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%defines
%output "parser.cpp"

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code{
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.lex
}

%define api.token.prefix {TOK_}
%token <std::string> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> NUMBER "number"                  // This defines TOK_NUMBER
%token <std::string> TRUE "true"
%token <std::string> FALSE "false"
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVETO "moveto"
%token <std::string> LAMBDA "lambda"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%token <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> LEFT_BRACE "{"
%token <std::string> RIGHT_BRACE "}"
%token <std::string> LEFT_PAREN "("
%token <std::string> RIGHT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> LESS_EQUAL "=<"
%token <std::string> GREATER_EQUAL "=>"
%token <std::string> LESS "<"
%token <std::string> GREATER ">"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%%

program: /* empty */ | args_term
args_term: types | args_term COMMA types;
types: INT | BOOL | STRING;
//op: PLUS;
//cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;
//dec_stmt: types IDENTIFIER ASSIGN expr SEMI | lambda_meth;
//if_term: IF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmt_block RIGHT_BRACE
//elif_term: ELIF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmt_block RIGHT_BRACE
//else_term: ELSE LEFT_BRACE stmt_block RIGHT_BRACE
//elif_block: elif_term | elif_block elif_term;
//if_stmt: if_term | if_term elif_block | if_term elif_block else_term

//event_def: DEFEVENT IDENTIFIER LEFT_PAREN 


%%

void yy::parser::error(const std::string& msg)
{
    std::cerr << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}