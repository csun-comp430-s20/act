/* yacc grammar for C++ */
%require "3.2"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%defines
%output "parser.cpp"

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code{
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.lex
}

%define api.token.prefix {TOK_}
%token <std::string> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> INT_NUMBER "number"              // This defines TOK_INT_NUMBER
%token <std::string> CONST_STRING "hello"
%token <std::string> TRUE "true"
%token <std::string> FALSE "false"
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVEIF "moveif"
%token <std::string> BREAK "break"
%token <std::string> LAMBDA "lambda"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%token <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> LEFT_BRACE "{"
%token <std::string> RIGHT_BRACE "}"
%token <std::string> LEFT_PAREN "("
%token <std::string> RIGHT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> AND_OP "&&"
%token <std::string> OR_OP "||"
%token <std::string> LESS_EQUAL "=<"
%token <std::string> GREATER_EQUAL "=>"
%token <std::string> LESS "<"
%token <std::string> GREATER ">"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%%

program: event_def_header | stmts | on_event_block;
// Statements
stmts: /* empty */ | dec_stmt | assign_stmt | if_stmt | while_stmt;
// On Event Block
on_event_block: on_event_term | on_event_block on_event_term;
on_event_term: ON IDENTIFIER LEFT_BRACE if_event_terms RIGHT_BRACE;
// If Event Block
if_event_terms: if_event_term | if_event_term elif_event_block | 
                if_event_term elif_event_block else_term;
if_event_term: MOVEIF LEFT_PAREN cond_expr RIGHT_PAREN IDENTIFIER 
               LEFT_BRACE stmts RIGHT_BRACE;
elif_event_block: elif_event_term | elif_event_block elif_event_term;
elif_event_term: MOVEIF LEFT_PAREN cond_expr RIGHT_PAREN IDENTIFIER 
                 LEFT_BRACE stmts RIGHT_BRACE;
// While Statement
while_stmt: while_term | while_stmt while_term;
while_term: WHILE LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmts RIGHT_BRACE;
// If-Else Statement
if_stmt: if_terms | if_stmt if_terms;
if_terms: if_term | if_term elif_block | if_term elif_block else_term;
if_term: IF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmts RIGHT_BRACE;
elif_block: elif_term | elif_block elif_term;
elif_term: ELIF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmts RIGHT_BRACE;
else_term: ELSE LEFT_BRACE stmts RIGHT_BRACE;
// Assignment
assign_stmt: assign_term | assign_stmt assign_term;
assign_term: IDENTIFIER ASSIGN exprs SEMI;
// Declarations
dec_stmt: dec_term | dec_stmt dec_term;
dec_term: types IDENTIFIER SEMI | types IDENTIFIER ASSIGN exprs SEMI;
// Expressions
exprs: cond_expr | add_expr;
// Arithmetic Cases
add_expr: add_vals | add_expr plus_op add_vals;
add_vals: INT_NUMBER | IDENTIFIER
plus_op: PLUS;
// Condition Cases
cond_expr: cond_term | cond_expr logic_op cond_term;
cond_term: logic_vals | logic_terms cond logic_terms | 
           LEFT_PAREN logic_terms cond logic_terms RIGHT_PAREN;
logic_terms: INT_NUMBER | CONST_STRING | IDENTIFIER | logic_vals;
logic_vals: TRUE | FALSE;
logic_op: AND_OP | OR_OP;
cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;
// Arg Cases
event_def_header: event_def_term | event_def_header event_def_term;
event_def_term: DEFEVENT IDENTIFIER LEFT_PAREN args_term RIGHT_PAREN SEMI;
args_term: types | args_term COMMA types;
types: INT | BOOL | STRING;

/*
if_term: IF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
elif_term: ELIF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
else_term: ELSE LEFT_BRACE ... RIGHT_BRACE
elif_block: elif_term | elif_block elif_term;
if_stmt: if_term | if_term elif_block | if_term elif_block else_term

logic_term: NUMBER | TRUE | FALSE
logic_op: AND_OP | OR_OP
cond_expr: cond_term | cond_expr logic_op cond_term
cond_term: logic_term | logic_term cond logic_term

args_term: types | args_term COMMA types
args_iden_term: types IDENTIFIER | args_iden_term COMMA types IDENTIFIER

event_def_header: DEFEVENT IDENTIFIER LEFT_PAREN args_term RIGHT_PAREN SEMI

if_event_stmt: IF LEFT_PAREN cond_expr RIGHT_PAREN MOVETO IDENTIFIER LEFT_BRACE ...
on_event_stmt: ON IDENTIFIER LEFT_BRACE if_event RIGHT_BRACE
while_stmt: WHILE LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
return_term: RETURN ...
method_term: types IDENTIFIER LEFT_PAREN args_iden_term RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
entry_meth: ENTRY LEFT_BRACE ... RIGHT_BRACE
exit_meth: EXIT LEFT_BRACE ... RIGHT_BRACE
lambda_meth: LAMBDA LEFT_PAREN args_iden_term RIGHT_PAREN LEFT_BRACE ... RIGHT_BRACE
add_expr: NUMBER | add_expr op NUMBER
state_term: STATE IDENTIFIER LEFT_BRACE entry_meth exit_meth ... RIGHT_BRACE

stmts_list: dec_stmt | if_stmt | on_event_stmt | while_stmt
*/

%%

void yy::parser::error(const std::string& msg)
{
    std::cerr << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}