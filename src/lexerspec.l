%top{
    #include "parser.hpp"  /* Generated by bison. */
    #include <string>
    #include <fstream>
%}

%option bison-complete
%option bison-cc-namespace=yy
%option bison-cc-parser=parser

%option exception="yy::parser::syntax_error(\"Unknown token.\")"
%option namespace=yy
%option lexer=Lexer

%%

"true"                      return yy::parser::make_TRUE(str());
"false"                     return yy::parser::make_FALSE(str());
"if"                        return yy::parser::make_IF(str());
"elif"                      return yy::parser::make_ELIF(str());
"else"                      return yy::parser::make_ELSE(str());
"while"                     return yy::parser::make_WHILE(str());
"return"                    return yy::parser::make_RETURN(str());
"state"                     return yy::parser::make_STATE(str());
"entry"                     return yy::parser::make_ENTRY(str());
"exit"                      return yy::parser::make_EXIT(str());
"on"                        return yy::parser::make_ON(str());
"moveto"                    return yy::parser::make_MOVETO(str());
"break"                     return yy::parser::make_BREAK(str());
"lambda"                    return yy::parser::make_LAMBDA(str());
"defevent"                  return yy::parser::make_DEFEVENT(str());
"int"                       return yy::parser::make_INT(str());
"bool"                      return yy::parser::make_BOOL(str());
"string"                    return yy::parser::make_STRING(str());
"+"                         return yy::parser::make_PLUS(str());
";"                         return yy::parser::make_SEMI(str());
"{"                         return yy::parser::make_LEFT_BRACE(str());
"}"                         return yy::parser::make_RIGHT_BRACE(str());
"("                         return yy::parser::make_LEFT_PAREN(str());
")"                         return yy::parser::make_RIGHT_PAREN(str());
","                         return yy::parser::make_COMMA(str());
"&&"                        return yy::parser::make_AND_OP(str());
"||"                        return yy::parser::make_OR_OP(str());
"=<"                        return yy::parser::make_LESS_EQUAL(str());
"=>"                        return yy::parser::make_GREATER_EQUAL(str());
"<"                         return yy::parser::make_LESS(str()); 
">"                         return yy::parser::make_GREATER(str()); 
"=="                        return yy::parser::make_EQUAL(str());
"="                         return yy::parser::make_ASSIGN(str());
<<EOF>>                     return yy::parser::make_EOF();
[a-zA-Z_][a-zA-Z0-9_]*      return yy::parser::make_IDENTIFIER(str());
[0-9]+                      return yy::parser::make_INT_NUMBER(atoi(text()));
\"([^\\\"]|\\\")*\"         return yy::parser::make_CONST_STRING(str());
"/*"(.|\n)*?"*/"            /* no action: ignore multiline comments */
[ \t\r\n]                   /* no action: ignore all white space */

%%

/*
int main(int argc, char **argv)
{
    FILE *fd = stdin;
    if (argc > 1 && (fd = fopen(argv[1], "r")) == NULL)
        exit(EXIT_FAILURE);
    std::ofstream of("output.txt", std::ofstream::out);
    if (!of)
        exit(EXIT_FAILURE);
    yy::Lexer lexer(fd, of);
    yy::parser parser(lexer);
    if (parser.parse() != 0) {}
    of.close();
    if (fd != stdin)
        fclose(fd);
    return 0;
}
*/
