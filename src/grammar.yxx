/* yacc grammar for C++ */
%require "3.2"
%language "c++"

%define api.namespace {yy}
%define api.parser.class {parser}
%define api.value.type variant
%define api.token.constructor

%defines
%output "parser.cpp"

%top{
    #include <string>
    #include "parser.hpp"  /* Generated by bison. */
%}

%option bison-complete
%option bison-cc-namespace=yy
%option bison-cc-parser=parser

%option exception="yy::parser::syntax_error(\"Unknown token.\")"

%option namespace=yy
%option lexer=Lexer

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code{
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()
}

%define api.token.prefix {TOK_}
%token <std::string> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> NUMBER "number"                  // This defines TOK_NUMBER
%token <bool> TRUE "true"
%token <bool> FALSE "false"
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVETO "moveto"
%token <std::string> LAMBDA "lambda"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%token <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> RIGHT_BRACE "{"
%token <std::string> LEFT_BRACE "}"
%token <std::string> RIGHT_PAREN "("
%token <std::string> LEFT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> LESS_EQUAL "=<"
%token <std::string> GREATER_EQUAL "=>"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%%

[a-zA-Z_][a-zA-Z0-9_]*      return yy::parser::make_IDENTIFIER(str());
[0-9]+                      return yy::parser::make_NUMBER(atoi(text()));
"true"                      return yy::parser::make_TRUE(str());
"false"                     return yy::parser::make_FALSE(str());
"if"                        return yy::parser::make_IF(str());
"elif"                      return yy::parser::make_ELIF(str());
"else"                      return yy::parser::make_ELSE(str());
"while"                     return yy::parser::make_WHILE(str());
"return"                    return yy::parser::make_RETURN(str());
"state"                     return yy::parser::make_STATE(str());
"entry"                     return yy::parser::make_ENTRY(str());
"exit"                      return yy::parser::make_EXIT(str());
"on"                        return yy::parser::make_ON(str());
"moveto"                    return yy::parser::make_MOVETO(str());
"lambda"                    return yy::parser::make_LAMBDA(str());
"defevent"                  return yy::parser::make_DEFEVENT(str());
"int"                       return yy::parser::make_INT(str());
"bool"                      return yy::parser::make_BOOL(str());
"string"                    return yy::parser::make_STRING(str());
"+"                         return yy::parser::make_PLUS(str());
";"                         return yy::parser::make_SEMI(str());
"{"                         return yy::parser::make_RIGHT_BRACE(str());
"}"                         return yy::parser::make_LEFT_BRACE(str());
"("                         return yy::parser::make_RIGHT_PAREN(str());
")"                         return yy::parser::make_LEFT_PAREN(str());
","                         return yy::parser::make_COMMA(str());
"=<"                        return yy::parser::make_LESS_EQUAL(str());
"=>"                        return yy::parser::make_GREATER_EQUAL(str());
"=="                        return yy::parser::make_EQUAL(str());
"="                         return yy::parser::make_ASSIGN(str());
<<EOF>>                     return yy::parser::make_EOF();
"/*"(.|\n)*?"*/"            /* no action: ignore multiline comments */
[ \t\r\n]                   /* no action: ignore all white space */

%%

void yy::parser::error(const std::string& msg)
{
    std::cerr << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}