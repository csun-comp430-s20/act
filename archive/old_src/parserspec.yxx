/* yacc grammar for C++ */
%require "3.5"
%language "c++"

%define api.namespace {yy}
%define api.parser.class {parser}
%define api.value.type variant
%define api.token.constructor

%define parse.error verbose

%defines
%output "parser.cpp"

%locations
%define api.location.file "location.hpp"

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }

    #include <stdlib.h>
    #include <cstdio>
    #include <list>
    #include "program.hpp"
}

%parse-param { yy::Lexer& lexer } { program& root }

%code{
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.lex

    // program root;  // the root of the abstract syntax tree
}

%start prog

%define api.token.prefix {TOK_}
%token <std::string> PRINT "print"
%token <std::string> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <int> INT_NUMBER 123                   // This defines TOK_INT_NUMBER
%token <std::string> STRING_VAL "hello"
%token <bool> TRUE true
%token <bool> FALSE false
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVEIF "moveif"
%token <std::string> BREAK "break"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%left <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> LEFT_BRACE "{"
%token <std::string> RIGHT_BRACE "}"
%left <std::string> LEFT_PAREN "("
%left <std::string> RIGHT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> LESS "<"
%token <std::string> GREATER ">"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0
%type <exp_node> exp
%type <statement> stmt
%type <std::list<statement>> stmtlist
%type <program> prog

%%

prog: stmtlist { $$ = program($1); root = $$; };
stmtlist: stmtlist stmt {
        // copy up the list and add the stmt to it
        $$ = $1;
        $1.push_back($2); }
    | %empty {
        $$ = std::list<statement>(); };
stmt: INT IDENTIFIER ASSIGN exp SEMI {
        $$ = assignment_stmt($1, $2, $4); }
    | PRINT LEFT_PAREN IDENTIFIER RIGHT_PAREN SEMI {
        $$ = print_stmt($3);
    };
//print_stmt: print_term | print_stmt print_term;
//print_term: PRINT LEFT_PAREN IDENTIFIER RIGHT_PAREN SEMI {
//    $$ = new print_stmt($3);
//}
// Assignment
//assign_stmt: assign_term | assign_stmt assign_term;
//assign_term: types IDENTIFIER ASSIGN exp SEMI;
// Expressions
//exprs: add_expr;
// Plus Cases
exp: exp PLUS exp {
        $$ = $1 + $3; }
    | INT_NUMBER {
        $$ = int_node($1); };
//types: INT | BOOL | STRING;

%%

int main()
{
    std::string args_str = "int var = 2 + 2;";

    program myroot;
    yy::Lexer lexer(args_str);
    yy::parser parser(lexer, myroot);

    if(parser.parse() != 0) {
        std::cout << "ERROR in parsing" << std::endl;
    }

    myroot.evaluate();
}

void yy::parser::error(const location& loc, const std::string& msg)
{
    std::cerr << loc << ": " << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}