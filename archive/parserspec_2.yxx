/* yacc grammar for C++ */
%require "3.2"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%defines
%output "parser.cpp"

%code requires{
    namespace yy {
        class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
}

%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code{
    #include <map>
    #include <list>
    #include "lex.yy.h"  // header file generated with reflex --header-file
    #undef yylex
    #define yylex lexer.lex

    pgm *root;  // the root of the abstract syntax tree
    int line_num = 1;   // keeps track of line number
}

%start program

%union {
    int num;
    std::string id;
    exp_node *expnode;
    list<statement *> *stmts;
    statement *st;
    pgm *prog;
}

%define api.token.prefix {TOK_}
%token <id> IDENTIFIER "identifier"  // This defines TOK_IDENTIFIER
%token <num> INT_NUMBER "number"              // This defines TOK_INT_NUMBER
%token <std::string> CONST_STRING "hello"
%token <std::string> TRUE "true"
%token <std::string> FALSE "false"
%token <std::string> IF "if"
%token <std::string> ELIF "elif"
%token <std::string> ELSE "else"
%token <std::string> WHILE "while"
%token <std::string> RETURN "return"
%token <std::string> STATE "state"
%token <std::string> ENTRY "entry"
%token <std::string> EXIT "exit"
%token <std::string> ON "on"
%token <std::string> MOVEIF "moveif"
%token <std::string> BREAK "break"
%token <std::string> LAMBDA "lambda"
%token <std::string> DEFEVENT "defevent"
%token <std::string> INT "int"
%token <std::string> BOOL "bool"
%token <std::string> STRING "string"
%left <std::string> PLUS "+"
%token <std::string> SEMI ";"
%token <std::string> LEFT_BRACE "{"
%token <std::string> RIGHT_BRACE "}"
%left <std::string> LEFT_PAREN "("
%left <std::string> RIGHT_PAREN ")"
%token <std::string> COMMA ","
%token <std::string> AND_OP "&&"
%token <std::string> OR_OP "||"
%token <std::string> LESS_EQUAL "=<"
%token <std::string> GREATER_EQUAL "=>"
%token <std::string> LESS "<"
%token <std::string> GREATER ">"
%token <std::string> EQUAL "=="
%token <std::string> ASSIGN "="
%token EOF 0 "end of file"                    // This defines TOK_EOF with value 0

%%

/*
program: /* empty */ | event_def_header | state_block;
// State Block
state_block: STATE LEFT_BRACE entry_meth exit_meth state_stmts RIGHT_BRACE |
             STATE LEFT_BRACE entry_meth state_stmts RIGHT_BRACE |
             STATE LEFT_BRACE exit_meth state_stmts RIGHT_BRACE |
             STATE LEFT_BRACE state_stmts RIGHT_BRACE;
state_stmts: stmts | on_event_block | method_def | state_block;
// Entry Method
entry_meth: ENTRY LEFT_BRACE stmts RIGHT_BRACE;
// Exit Method
exit_meth: EXIT LEFT_BRACE stmts RIGHT_BRACE;
// Method Definition
method_def: types IDENTIFIER LEFT_PAREN args_type_iden RIGHT_PAREN
            LEFT_BRACE method_stmts RIGHT_BRACE;
method_stmts: /* empty */ | dec_stmt | assign_stmt | if_stmt |
              while_stmt | return_stmt;
// Statements
stmts: /* empty */ | dec_stmt | assign_stmt | if_stmt | while_stmt;
// On Event Block
on_event_block: on_event_term | on_event_block on_event_term;
on_event_term: ON IDENTIFIER LEFT_PAREN args_iden RIGHT_PAREN 
               LEFT_BRACE if_event_terms RIGHT_BRACE;
// If Event Block
if_event_terms: if_event_term | if_event_term elif_event_block | 
                if_event_term elif_event_block else_term;
if_event_term: MOVEIF LEFT_PAREN cond_expr RIGHT_PAREN IDENTIFIER 
               LEFT_BRACE stmts RIGHT_BRACE;
elif_event_block: elif_event_term | elif_event_block elif_event_term;
elif_event_term: MOVEIF LEFT_PAREN cond_expr RIGHT_PAREN IDENTIFIER 
                 LEFT_BRACE stmts RIGHT_BRACE;
// Return Statement
return_stmt: RETURN simple_exprs SEMI;
// While Statement
while_stmt: while_term | while_stmt while_term;
while_term: WHILE LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE while_stmts RIGHT_BRACE;
while_stmts: /* empty */ | dec_stmt | assign_stmt | if_stmt | while_stmt | break_stmt;
break_stmt: BREAK SEMI;
// If-Else Statement
if_stmt: if_terms | if_stmt if_terms;
if_terms: if_term | if_term elif_block | if_term elif_block else_term;
if_term: IF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmts RIGHT_BRACE;
elif_block: elif_term | elif_block elif_term;
elif_term: ELIF LEFT_PAREN cond_expr RIGHT_PAREN LEFT_BRACE stmts RIGHT_BRACE;
else_term: ELSE LEFT_BRACE stmts RIGHT_BRACE;
// Assignment
assign_stmt: assign_term | assign_stmt assign_term;
assign_term: IDENTIFIER ASSIGN exprs SEMI;
// Declarations
dec_stmt: dec_term | dec_stmt dec_term;
dec_term: types IDENTIFIER SEMI | types IDENTIFIER ASSIGN exprs SEMI;
// Expressions
exprs: lambda_def | cond_expr | add_expr;
// Lambda Definition
lambda_def: LAMBDA LEFT_PAREN args_type_iden RIGHT_PAREN LEFT_BRACE simple_exprs RIGHT_BRACE
simple_exprs: cond_expr | add_expr;
// Arithmetic Cases
add_expr: add_vals | add_expr plus_op add_vals;
add_vals: INT_NUMBER | IDENTIFIER
plus_op: PLUS;
// Condition Cases
cond_expr: cond_term | cond_expr logic_op cond_term;
cond_term: logic_vals | logic_terms cond logic_terms | 
           LEFT_PAREN logic_terms cond logic_terms RIGHT_PAREN;
logic_terms: INT_NUMBER | CONST_STRING | IDENTIFIER | logic_vals;
logic_vals: TRUE | FALSE;
logic_op: AND_OP | OR_OP;
cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;
*/

program: /* empty */ | event_def_header | stmt;
stmt: print_stmt | assign_stmt;
print_stmt: print_term | print_stmt print_term;
print_term: PRINT LEFT_PAREN IDENTIFIER RIGHT_PAREN SEMI {
    $$ = new print_stmt($3);
}
// Assignment
assign_stmt: assign_term | assign_stmt assign_term;
assign_term: IDENTIFIER ASSIGN exprs SEMI;
// Declarations
dec_stmt: dec_term | dec_stmt dec_term;
dec_term: types IDENTIFIER SEMI | types IDENTIFIER ASSIGN exprs SEMI;
// Expressions
exprs: lambda_def | cond_expr | add_expr;
// Lambda Definition
lambda_def: LAMBDA LEFT_PAREN args_type_iden RIGHT_PAREN LEFT_BRACE simple_exprs RIGHT_BRACE
simple_exprs: cond_expr | add_expr;
// Arithmetic Cases
add_expr: add_vals | add_expr plus_op add_vals;
add_vals: INT_NUMBER | IDENTIFIER
plus_op: PLUS;
// Condition Cases
cond_expr: cond_term | cond_expr logic_op cond_term;
cond_term: logic_vals | logic_terms cond logic_terms | 
           LEFT_PAREN logic_terms cond logic_terms RIGHT_PAREN;
logic_terms: INT_NUMBER | CONST_STRING | IDENTIFIER | logic_vals;
logic_vals: TRUE | FALSE;
logic_op: AND_OP | OR_OP;
cond: LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL;
// Event Def Cases
event_def_header: event_def_term | event_def_header event_def_term;
event_def_term: DEFEVENT IDENTIFIER LEFT_PAREN args_types RIGHT_PAREN SEMI;
// Args Cases
//args_type_iden: /* empty */ | types IDENTIFIER | args_type_iden COMMA types IDENTIFIER;
//args_iden: /* empty */ | IDENTIFIER | args_iden COMMA IDENTIFIER;
args_types: /* empty */ | types | args_types COMMA types;
types: INT | BOOL | STRING;

%%

void yy::parser::error(const std::string& msg)
{
    std::cerr << "line " << std::to_string(line_num) << ": " << msg << std::endl;
    if (lexer.size() == 0)      // if token is unknown (no match)
        lexer.matcher().winput(); // skip character
}